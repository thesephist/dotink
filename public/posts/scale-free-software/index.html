<!DOCTYPE html>

<head>
	<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<link href="https://fonts.googleapis.com/css?family=IBM+Plex+Mono:400,400i,600|IBM+Plex+Sans:400,400i,600,600i&display=swap" rel="stylesheet">
<link rel="stylesheet" href="/css/main.css" />


	<title>Scale-free software | Ink</title>
	
	<link rel="canonical" href="https://dotink.co/posts/scale-free-software/" />
	
</head>

<body class="type-page">
	<header>
    <div class="overlay">
        <div class="home">
            <a href="/">.ink</a>
        </div>
        <nav>
            <a href="/docs/">docs</a>
            <a href="/posts/">posts</a>
            <a href="https://github.com/thesephist/ink">github</a>
        </nav>
    </div>
</header>


	

<main aria-role="main">
    <div class="hero inverted">
        <div class="overlay">
            <h1>Scale-free software</h1>
        </div>
        <div class="meta overlay">
            <div class="meta-item date" itemprop="datepublished">2 August 2020</div>
            <div class="meta-item readtime" itemprop="duration">4 mins</div>
        </div>
    </div>
    <article class="overlay">
        

        <p>Good software engineering is concerned with two kinds of scale: operational scale and engineering scale.</p>
<p><strong>Operational scale</strong> measures how many processors and compute nodes are in your production infrastructure, and how many requests and responses the system handles every second. The higher these numbers, the greater the operational scale. Operational scaling problems are caused by single points of dependency that become bottlenecks, like an implicit assumption on a single database, or an algorithm that becomes slow with large datasets in a critical path.</p>
<p><strong>Engineering scale</strong> is about the <em>production</em> of software. Software evolves over time, and maintaining software systems gets more difficult with time, and with larger teams in large organizations. Software without well-designed interfaces between components or poorly documented APIs will get more difficult to maintain as a team grows to hundreds and thousands of people. Well-designed software systems scale well in this engineering axis, as well as servicing a high operational workload.</p>
<p>Engineering scale is especially important for open source projects, where potentially tens of thousands of relative strangers need to come together and converge on what to build, how to design it, and how to contribute to a single project in a way that stabilizes and guarantees a future for the project.</p>
<p>To build scalable software, we need to service both of these independent axes of operational and engineering scale.</p>
<p>I&rsquo;m not sure where I first heard it, but I recently heard the phrase &ldquo;scale-free software&rdquo; and thought it was an interesting way to think about composing large scalable software systems.</p>
<h2 id="scale-free-software-primitives">Scale-free software primitives</h2>
<p>I think whenever possible, <strong>large scalable software systems are best composed of small, scale-free parts</strong>.</p>
<p>A scale-free software component is one that doesn&rsquo;t need to change behavior as a result of scale. Scale-free components are desirable because large scalable systems can be composed straightforwardly out of scale-free parts, whereas if those components had to change as the size of the problem increased, scaling the whole system would require lots of understanding and thinking across layers of abstraction.</p>
<p>In achieving operational scale, two common scale-free primitives are embarrassingly parallel problems and purely functional algorithms. Both kinds of paradigms allow components to be written in a way such that a macroscopic system can scale the number of components in a system freely to scale throughput, without each component having to account for scaling effects to its particular implementation. These components can also readily take advantage of parallelism.</p>
<p>In a more practical context, a well-designed microservice architecture is a scalable system composed of scale-free parts. Ideally, each microservice exhibits the same behavior regardless of whether there is one instance running or ten million. The problem of coordinating these scale-free components is relegated to a specific part of the macroscopic system like a service mesh, and wherever that encapsulation holds, each microservice can be designed without worrying about emergent problems of scale.</p>
<p>What does scale-free design look like in achieving engineering scale?</p>
<p>I think the theme of scale-free design in collaboration is good interface design. Interfaces between software components include the literal interfaces of the APIs, but also things like release schedules, deprecation timelines, and versioning schemes. Designing and agreeing on a common set of interfaces, writ large like this, allows each specific sub-team to work more independently, and allows the entire organization to grow by adding more teams, not necessary perfectly, but more easily than would otherwise be possible.</p>
<p>Large open source ecosystems built around semantic versioning, like Node&rsquo;s NPM ecosystem and Rust&rsquo;s Crate repository, are good examples of engineering scale that&rsquo;s seen success by building on well-defined interfaces between software components. There are exceptions, yes, but those exceptions prove the rule.</p>
<p>Another place to make engineering team components more scale-free is by being more diligent about the dependencies a project takes on. An external software dependency is another engineering team whose output matters in the current project, and we should strive to narrow those points of integration and scope them to be as stable and uninterruptive as possible.</p>
<p>When we compose large systems from smaller scale-free components, it&rsquo;s easier to abstract away effects of scale to the macroscopic system, while letting the authors and operation of each component worry about their specific problems. This doesn&rsquo;t mean each component can be written with complete disregard to performance or efficiency. Rather, composing large systems like this allows each component to only worry about performance problems at its level of abstraction. Importantly, complexities of large distributed services like consensus and availability can be relegated to the higher levels of design, where components are fit together, while each component service can worry about the efficient implementation of its own job.</p>

        <hr/>
        <p class="prevInSection">
            
            &larr;
            <a href="https://dotink.co/posts/gpt3/"><em>A discussion on NLP, GPT-3, and language models</em></a>
            
        </p>
        <p class="nextInSection">
            
            <a href="https://dotink.co/posts/september/"><em>The September compiler: translating Ink to JavaScript</em></a>
            &rarr;
            
        </p>
    </article>
</main>



	<footer>
    <div class="overlay">
        <div class="left">
            <p>- Linus</p>
        </div>
        <div class="right">
            <span class="square"></span>
        </div>
    </div>
</footer>


	
</body>
